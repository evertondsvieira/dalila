// This file is auto-generated by 'dalila routes generate'
// Do not edit manually - your changes will be overwritten

export type RoutePattern = '/' | '/about';

export type RouteParamsByPattern = {
  '/': {};
  '/about': {};
};

export type RouteSearchByPattern = {
  [P in RoutePattern]: Record<string, string | string[]>;
};

export type RouteParams<P extends RoutePattern> = RouteParamsByPattern[P];
export type RouteSearch<P extends RoutePattern> = RouteSearchByPattern[P];

export function buildRoutePath<P extends RoutePattern>(pattern: P, params: RouteParams<P>): string {
  const out: string[] = [];
  for (const segment of pattern.split('/').filter(Boolean)) {
    if (!segment.startsWith(':')) {
      out.push(segment);
      continue;
    }

    const isOptionalCatchAll = segment.endsWith('*?');
    const isCatchAll = isOptionalCatchAll || segment.endsWith('*');
    const key = segment.slice(1, isCatchAll ? (isOptionalCatchAll ? -2 : -1) : undefined);
    const value = (params as Record<string, unknown>)[key];

    if (isCatchAll) {
      if (value === undefined || value === null) {
        if (isOptionalCatchAll) continue;
        throw new Error(`Missing route param: ${key}`);
      }
      if (!Array.isArray(value)) {
        throw new Error(`Route param "${key}" must be an array`);
      }
      if (value.length === 0) {
        if (isOptionalCatchAll) continue;
        throw new Error(`Route param "${key}" cannot be empty`);
      }
      out.push(...value.map(v => encodeURIComponent(String(v))));
      continue;
    }

    if (value === undefined || value === null) {
      throw new Error(`Missing route param: ${key}`);
    }
    out.push(encodeURIComponent(String(value)));
  }

  return out.length === 0 ? '/' : `/${out.join('/')}`;
}
