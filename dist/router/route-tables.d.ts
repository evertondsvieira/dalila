import type { Scope } from '../core/scope.js';
import type { Rule } from './validation.js';
/** Options for programmatic navigation. */
export interface NavigateOptions {
    replace?: boolean;
}
/** Context passed to views, loaders, guards, and middleware. */
export interface RouteCtx {
    path: string;
    fullPath: string;
    params: Record<string, RouteParamValue>;
    query: URLSearchParams;
    hash: string;
    signal: AbortSignal;
    scope: Scope;
    navigate: (to: string, options?: NavigateOptions) => Promise<void>;
}
export type RouteParamValue = string | string[];
export type RouteParamsValues = Record<string, RouteParamValue>;
export type RouteQueryValue = string | string[] | undefined;
export type RouteQueryValues = Record<string, string | string[]>;
export type RouteParamValidationValue = RouteParamValue | undefined;
export type RouteQueryValidationSchema = Record<string, Array<Rule<RouteQueryValue, RouteQueryValues>>>;
export type RouteParamsValidationSchema = Record<string, Array<Rule<RouteParamValidationValue, RouteParamsValues>>>;
/** Schema for params/query validation (router built-in rule format). */
export interface RouteValidationConfig {
    query?: RouteQueryValidationSchema;
    params?: RouteParamsValidationSchema;
}
export type RouteValidationResolver = RouteValidationConfig | (() => RouteValidationConfig | null | undefined | Promise<RouteValidationConfig | null | undefined>);
export type RouteGuardResult = boolean | string | null | undefined | Promise<boolean | string | null | undefined>;
export type RouteRedirectResult = string | null | undefined | Promise<string | null | undefined>;
export type RouteMiddlewareResult = RouteGuardResult;
export type RouteMiddleware = (ctx: RouteCtx) => RouteMiddlewareResult;
export type RouteMiddlewareResolver = RouteMiddleware[] | ((ctx: RouteCtx) => RouteMiddleware[] | null | undefined | Promise<RouteMiddleware[] | null | undefined>);
/**
 * Route definition.
 *
 * Describes a single node in the route tree: path, view/layout,
 * data loading, state views, children, guards, middleware, redirects,
 * and params/query validation.
 */
export interface RouteTable<T = any> {
    path: string;
    id?: string;
    score?: number;
    paramKeys?: string[];
    tags?: string[];
    view?: (ctx: RouteCtx, data: T) => Node | DocumentFragment | Node[];
    layout?: (ctx: RouteCtx, child: Node | DocumentFragment | Node[], data: T) => Node | DocumentFragment | Node[];
    loader?: (ctx: RouteCtx) => Promise<T>;
    preload?: (ctx: RouteCtx) => Promise<T>;
    onMount?: (root: HTMLElement) => void;
    pending?: (ctx: RouteCtx) => Node | DocumentFragment | Node[];
    error?: (ctx: RouteCtx, error: unknown, data?: T) => Node | DocumentFragment | Node[];
    notFound?: (ctx: RouteCtx) => Node | DocumentFragment | Node[];
    children?: RouteTable[];
    middleware?: RouteMiddlewareResolver;
    guard?: (ctx: RouteCtx) => RouteGuardResult;
    redirect?: string | ((ctx: RouteCtx) => RouteRedirectResult);
    validation?: RouteValidationResolver;
}
/**
 * Helper to define a single route with full type inference between
 * `loader` return type and the `view` / `layout` / `error` `data` parameter.
 *
 * @example
 * ```ts
 * const route = defineRoute({
 *   path: '/users',
 *   loader: async () => ({ users: await fetchUsers() }),
 *   view: (ctx, data) => {
 *     // data is inferred as { users: User[] }
 *     return fromHtml(tpl, { data });
 *   },
 * });
 * ```
 */
export declare function defineRoute<T = any>(route: RouteTable<T>): RouteTable<T>;
/** Immutable snapshot of the current navigation state. */
export interface RouteState {
    path: string;
    fullPath: string;
    params: Record<string, RouteParamValue>;
    queryString: string;
    query: URLSearchParams;
    hash: string;
}
/** Entry from the file-based route manifest (generated by the CLI). */
export interface RouteManifestEntry {
    id: string;
    pattern: string;
    score: number;
    paramKeys: string[];
    tags: string[];
    primaryTag?: string;
    modules: string[];
    load: () => Promise<void>;
}
/** A single matched route with extracted params. */
export interface RouteTableMatch {
    route: RouteTable;
    path: string;
    params: Record<string, RouteParamValue>;
}
/** Result of route matching: the matched stack and whether the match is exact. */
export interface RouteStackResult {
    stack: RouteTableMatch[];
    exact: boolean;
}
/**
 * Pre-compiled route node.
 *
 * Regex patterns and sort order are computed once at init by `compileRoutes`.
 * Subsequent matching uses this tree with zero recompilation.
 */
export interface CompiledRoute {
    route: RouteTable;
    fullPath: string;
    exactPattern: RegExp;
    /** null means root "/" which always matches as prefix */
    prefixPattern: RegExp | null;
    paramCaptures: ParamCapture[];
    children: CompiledRoute[];
}
/** Normalize a path: ensure leading slash, collapse duplicates, strip trailing slash. */
export declare function normalizePath(path: string): string;
interface ParamCapture {
    name: string;
    isCatchAll: boolean;
}
/**
 * Compile the route tree into a pre-sorted, regex-ready structure.
 *
 * Called once at init. Subsequent route matching uses the compiled tree
 * without recompilation or re-sorting.
 */
export declare function compileRoutes(routes: RouteTable[], parentPath?: string): CompiledRoute[];
/**
 * Find the deepest matching route stack for a pathname.
 *
 * Returns the full parent-to-leaf match chain and whether the match
 * is exact (has a view/redirect) or partial (layout/prefix only).
 */
export declare function findCompiledRouteStackResult(pathname: string, compiled: CompiledRoute[], stack?: RouteTableMatch[]): RouteStackResult | null;
export {};
