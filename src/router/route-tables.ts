import type { Scope } from '../core/scope.js';
import type { Rule } from './validation.js';

/** Options for programmatic navigation. */
export interface NavigateOptions {
  replace?: boolean;
}

/** Context passed to views, loaders, guards, and middleware. */
export interface RouteCtx {
  path: string;
  fullPath: string;
  params: Record<string, RouteParamValue>;
  query: URLSearchParams;
  hash: string;
  signal: AbortSignal;
  scope: Scope;
  navigate: (to: string, options?: NavigateOptions) => Promise<void>;
}

export type RouteParamValue = string | string[];
export type RouteParamsValues = Record<string, RouteParamValue>;

export type RouteQueryValue = string | string[] | undefined;
export type RouteQueryValues = Record<string, string | string[]>;
export type RouteParamValidationValue = RouteParamValue | undefined;
export type RouteQueryValidationSchema = Record<string, Array<Rule<RouteQueryValue, RouteQueryValues>>>;
export type RouteParamsValidationSchema = Record<string, Array<Rule<RouteParamValidationValue, RouteParamsValues>>>;

/** Schema for params/query validation (router built-in rule format). */
export interface RouteValidationConfig {
  query?: RouteQueryValidationSchema;
  params?: RouteParamsValidationSchema;
}

export type RouteValidationResolver =
  | RouteValidationConfig
  | (() => RouteValidationConfig | null | undefined | Promise<RouteValidationConfig | null | undefined>);

export type RouteGuardResult = boolean | string | null | undefined | Promise<boolean | string | null | undefined>;
export type RouteRedirectResult = string | null | undefined | Promise<string | null | undefined>;
export type RouteMiddlewareResult = RouteGuardResult;
export type RouteMiddleware = (ctx: RouteCtx) => RouteMiddlewareResult;
export type RouteMiddlewareResolver =
  | RouteMiddleware[]
  | ((ctx: RouteCtx) => RouteMiddleware[] | null | undefined | Promise<RouteMiddleware[] | null | undefined>);
export type RouteMountCleanup = () => void;
export type RouteMountResult = void | RouteMountCleanup | Promise<void | RouteMountCleanup>;
export type RouteUnmountResult = void | Promise<void>;

/**
 * Route definition.
 *
 * Describes a single node in the route tree: path, view/layout,
 * data loading, state views, children, guards, middleware, redirects,
 * and params/query validation.
 */
export interface RouteTable<T = any> {
  path: string;
  id?: string;
  score?: number;
  paramKeys?: string[];
  tags?: string[];

  // Leaf view (final page)
  view?: (ctx: RouteCtx, data: T) => Node | DocumentFragment | Node[];

  // Layout wraps children
  layout?: (ctx: RouteCtx, child: Node | DocumentFragment | Node[], data: T) => Node | DocumentFragment | Node[];

  // Data loading
  loader?: (ctx: RouteCtx) => Promise<T>;
  preload?: (ctx: RouteCtx) => Promise<T>;

  // Post-mount lifecycle hook (called after view is mounted to DOM)
  // Receives the leaf loader data and route context.
  // May return a cleanup function that runs automatically on route leave/replace.
  onMount?: (root: HTMLElement, data: T, ctx: RouteCtx) => RouteMountResult;
  // Pre-unmount lifecycle hook (called before route content is replaced/cleared)
  // Receives the previous leaf loader data and route context.
  onUnmount?: (root: HTMLElement, data: T, ctx: RouteCtx) => RouteUnmountResult;

  // State views
  pending?: (ctx: RouteCtx) => Node | DocumentFragment | Node[];
  error?: (ctx: RouteCtx, error: unknown, data?: T) => Node | DocumentFragment | Node[];
  notFound?: (ctx: RouteCtx) => Node | DocumentFragment | Node[];

  children?: RouteTable[];
  middleware?: RouteMiddlewareResolver;
  guard?: (ctx: RouteCtx) => RouteGuardResult;
  redirect?: string | ((ctx: RouteCtx) => RouteRedirectResult);
  validation?: RouteValidationResolver;
}

/**
 * Helper to define a single route with full type inference between
 * `loader` return type and the `view` / `layout` / `error` `data` parameter.
 *
 * @example
 * ```ts
 * const route = defineRoute({
 *   path: '/users',
 *   loader: async () => ({ users: await fetchUsers() }),
 *   view: (ctx, data) => {
 *     // data is inferred as { users: User[] }
 *     return fromHtml(tpl, { data });
 *   },
 * });
 * ```
 */
export function defineRoute<T = any>(route: RouteTable<T>): RouteTable<T> {
  return route;
}

/** Immutable snapshot of the current navigation state. */
export interface RouteState {
  path: string;
  fullPath: string;
  params: Record<string, RouteParamValue>;
  queryString: string;
  query: URLSearchParams;
  hash: string;
}

/** Entry from the file-based route manifest (generated by the CLI). */
export interface RouteManifestEntry {
  id: string;
  pattern: string;
  score: number;
  paramKeys: string[];
  tags: string[];
  primaryTag?: string;
  modules: string[];
  load: () => Promise<void>;
}

/** A single matched route with extracted params. */
export interface RouteTableMatch {
  route: RouteTable;
  path: string;
  params: Record<string, RouteParamValue>;
}

/** Result of route matching: the matched stack and whether the match is exact. */
export interface RouteStackResult {
  stack: RouteTableMatch[];
  exact: boolean;
}

/**
 * Pre-compiled route node.
 *
 * Regex patterns and sort order are computed once at init by `compileRoutes`.
 * Subsequent matching uses this tree with zero recompilation.
 */
export interface CompiledRoute {
  route: RouteTable;
  fullPath: string;
  exactPattern: RegExp;
  /** null means root "/" which always matches as prefix */
  prefixPattern: RegExp | null;
  paramCaptures: ParamCapture[];
  children: CompiledRoute[];
}

/** Normalize a path: ensure leading slash, collapse duplicates, strip trailing slash. */
export function normalizePath(path: string): string {
  if (!path) return '/';
  let normalized = path.startsWith('/') ? path : `/${path}`;
  normalized = normalized.replace(/\/{2,}/g, '/');
  if (normalized.length > 1 && normalized.endsWith('/')) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}

function joinPaths(parent: string, child: string): string {
  if (!child || child === '.') return normalizePath(parent || '/');
  if (child.startsWith('/')) return normalizePath(child);

  const base = normalizePath(parent || '/');
  const trimmedBase = base === '/' ? '' : base;
  return normalizePath(`${trimmedBase}/${child}`);
}

/**
 * Rank a path segment for sorting.
 *
 * Higher rank = higher priority: static (2) > missing/parent (1.5) > dynamic (1) > wildcard (0).
 * The "missing" rank ensures parent routes are explored before dynamic siblings
 * so that static children get a chance to match first.
 */
function segmentRank(segment: string, index: number): number {
  if (!segment) {
    // A missing segment means a shorter (parent) path. Rank it above dynamic
    // segments so the parent's children are explored before dynamic siblings.
    return index === 0 ? 2 : 1.5;
  }
  if (segment.includes('*')) return 0;
  if (segment.startsWith(':')) return 1;
  return 2;
}

function compareRoutePaths(aPath: string, bPath: string): number {
  const aSegments = normalizePath(aPath).split('/').filter(Boolean);
  const bSegments = normalizePath(bPath).split('/').filter(Boolean);
  const max = Math.max(aSegments.length, bSegments.length);

  for (let i = 0; i < max; i += 1) {
    const aSeg = aSegments[i] ?? '';
    const bSeg = bSegments[i] ?? '';
    const aRank = segmentRank(aSeg, i);
    const bRank = segmentRank(bSeg, i);

    if (aRank !== bRank) {
      const aIsOptionalCatchAll = aSeg.startsWith(':') && aSeg.endsWith('*?');
      const bIsOptionalCatchAll = bSeg.startsWith(':') && bSeg.endsWith('*?');

      if (!aSeg && bIsOptionalCatchAll) return -1;
      if (!bSeg && aIsOptionalCatchAll) return 1;

      return bRank - aRank;
    }

    if (aRank === 2 && aSeg !== bSeg) {
      if (aSeg.length !== bSeg.length) {
        return bSeg.length - aSeg.length;
      }
      return aSeg.localeCompare(bSeg);
    }
  }

  if (aSegments.length !== bSegments.length) {
    return bSegments.length - aSegments.length;
  }

  return aPath.localeCompare(bPath);
}

function sortRoutes(routes: RouteTable[]): RouteTable[] {
  return [...routes].sort((a, b) => compareRoutePaths(a.path, b.path));
}

function escapeRegexSegment(segment: string): string {
  return segment.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

interface DynamicSegment {
  name: string;
  isCatchAll: boolean;
  isOptionalCatchAll: boolean;
}

interface ParamCapture {
  name: string;
  isCatchAll: boolean;
}

function parseDynamicSegment(segment: string): DynamicSegment | null {
  if (!segment.startsWith(':')) return null;

  const raw = segment.slice(1);
  if (!raw) return null;

  if (raw.endsWith('*?')) {
    const name = raw.slice(0, -2);
    if (!name) return null;
    return { name, isCatchAll: true, isOptionalCatchAll: true };
  }

  if (raw.endsWith('*')) {
    const name = raw.slice(0, -1);
    if (!name) return null;
    return { name, isCatchAll: true, isOptionalCatchAll: false };
  }

  return { name: raw, isCatchAll: false, isOptionalCatchAll: false };
}

function buildSegmentsPattern(segments: string[], paramCaptures: ParamCapture[]): string {
  let pattern = '^';
  for (let index = 0; index < segments.length; index += 1) {
    const segment = segments[index];
    const isLast = index === segments.length - 1;

    if (segment === '*') {
      pattern += '/.*';
      continue;
    }

    const dynamic = parseDynamicSegment(segment);
    if (dynamic) {
      if (dynamic.isCatchAll) {
        if (dynamic.isOptionalCatchAll) {
          pattern += isLast ? '(?:/(.*))?' : '(?:/(.*?))?';
        } else {
          pattern += '/';
          pattern += isLast ? '(.+)' : '(.+?)';
        }
      } else {
        pattern += '/([^/]+)';
      }
      paramCaptures.push({ name: dynamic.name, isCatchAll: dynamic.isCatchAll });
      continue;
    }

    pattern += `/${escapeRegexSegment(segment)}`;
  }
  return pattern;
}

function parsePath(path: string): { pattern: RegExp; paramCaptures: ParamCapture[] } {
  const normalized = normalizePath(path);
  const segments = normalized.split('/').filter(Boolean);
  const paramCaptures: ParamCapture[] = [];

  if (segments.length === 0) {
    return { pattern: /^\/$/, paramCaptures };
  }

  const pattern = buildSegmentsPattern(segments, paramCaptures) + '$';
  return { pattern: new RegExp(pattern), paramCaptures };
}

function parsePathPrefix(path: string): { pattern: RegExp; paramCaptures: ParamCapture[] } {
  const normalized = normalizePath(path);
  const segments = normalized.split('/').filter(Boolean);
  const paramCaptures: ParamCapture[] = [];

  if (segments.length === 0) {
    return { pattern: /^\/(?:|$)/, paramCaptures };
  }

  const pattern = buildSegmentsPattern(segments, paramCaptures) + '(?:/|$)';
  return { pattern: new RegExp(pattern), paramCaptures };
}

function decodeRouteParam(raw: string): string {
  try {
    return decodeURIComponent(raw);
  } catch {
    return raw;
  }
}

function decodeCatchAllParam(raw: string): string[] {
  if (!raw) return [];
  return raw.split('/').filter(Boolean).map(decodeRouteParam);
}

function extractParams(match: RegExpMatchArray, paramCaptures: ParamCapture[]): Record<string, RouteParamValue> {
  const params: Record<string, RouteParamValue> = {};
  for (let i = 0; i < paramCaptures.length; i += 1) {
    const capture = paramCaptures[i];
    const raw = match[i + 1] ?? '';
    params[capture.name] = capture.isCatchAll
      ? decodeCatchAllParam(raw)
      : decodeRouteParam(raw);
  }
  return params;
}

/**
 * Compile the route tree into a pre-sorted, regex-ready structure.
 *
 * Called once at init. Subsequent route matching uses the compiled tree
 * without recompilation or re-sorting.
 */
export function compileRoutes(routes: RouteTable[], parentPath = ''): CompiledRoute[] {
  return sortRoutes(routes).map(route => {
    const fullPath = joinPaths(parentPath, route.path);
    const normalizedFull = normalizePath(fullPath);
    const exact = parsePath(fullPath);
    const prefix = normalizedFull === '/'
      ? null
      : parsePathPrefix(fullPath);

    return {
      route,
      fullPath,
      exactPattern: exact.pattern,
      prefixPattern: prefix?.pattern ?? null,
      paramCaptures: exact.paramCaptures,
      children: route.children
        ? compileRoutes(route.children, fullPath)
        : []
    };
  });
}

/** Test a pathname against a compiled route's exact pattern. */
function matchCompiled(pathname: string, compiled: CompiledRoute): Record<string, RouteParamValue> | null {
  const match = pathname.match(compiled.exactPattern);
  if (!match) return null;
  return extractParams(match, compiled.paramCaptures);
}

/** Test a pathname against a compiled route's prefix pattern (for parent/layout matching). */
function matchCompiledPrefix(pathname: string, compiled: CompiledRoute): Record<string, RouteParamValue> | null {
  if (!compiled.prefixPattern) return {};
  const match = pathname.match(compiled.prefixPattern);
  if (!match) return null;
  return extractParams(match, compiled.paramCaptures);
}

/**
 * Find the deepest matching route stack for a pathname.
 *
 * Returns the full parent-to-leaf match chain and whether the match
 * is exact (has a view/redirect) or partial (layout/prefix only).
 */
export function findCompiledRouteStackResult(
  pathname: string,
  compiled: CompiledRoute[],
  stack: RouteTableMatch[] = []
): RouteStackResult | null {
  const normalizedPathname = normalizePath(pathname);
  return findCompiledRouteStackResultNormalized(normalizedPathname, compiled, stack);
}

function findCompiledRouteStackResultNormalized(
  pathname: string,
  compiled: CompiledRoute[],
  stack: RouteTableMatch[]
): RouteStackResult | null {
  let bestPartial: RouteTableMatch[] | null = null;

  for (const entry of compiled) {
    const exactParams = matchCompiled(pathname, entry);
    const prefixParams = !exactParams && (entry.route.children || entry.route.layout)
      ? matchCompiledPrefix(pathname, entry)
      : null;
    const params = exactParams || prefixParams;
    const isExact = Boolean(exactParams);

    if (params) {
      const match: RouteTableMatch = {
        route: entry.route,
        path: entry.fullPath,
        params
      };
      const newStack = [...stack, match];

      if (entry.children.length > 0) {
        const childResult = findCompiledRouteStackResultNormalized(pathname, entry.children, newStack);
        if (childResult) {
          if (childResult.exact) return childResult;
          if (!bestPartial || childResult.stack.length > bestPartial.length) {
            bestPartial = childResult.stack;
          }
        }
      }

      if (isExact && (entry.route.view || entry.route.redirect)) {
        return { stack: newStack, exact: true };
      }

      if (!isExact && (entry.route.layout || entry.route.children)) {
        if (!bestPartial || newStack.length > bestPartial.length) {
          bestPartial = newStack;
        }
      }
    } else if (entry.children.length > 0) {
      // Parent didn't match but children may have absolute-like paths
      const childResult = findCompiledRouteStackResultNormalized(pathname, entry.children, stack);
      if (childResult) {
        if (childResult.exact) return childResult;
        if (!bestPartial || childResult.stack.length > bestPartial.length) {
          bestPartial = childResult.stack;
        }
      }
    }
  }

  return bestPartial ? { stack: bestPartial, exact: false } : null;
}
